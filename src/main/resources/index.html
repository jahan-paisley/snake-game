<!doctype html>
<head>
    <meta charset="utf-8">
    <!-- Always force latest IE rendering engine (even in intranet) & Chrome Frame
         Remove this if you use the .htaccess -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Snake Charm</title>
    <style type="text/css">
        #ui * {
            width: 100%;
        }

        #ui textarea {
            height: 15em;
        }

        body {
            padding: 0;
            margin: 0;
            overflow: hidden;
        }
    </style>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.4.2/jquery.min.js"></script>
    <script src="https://cdn.jsdelivr.net/lodash/4.16.4/lodash.min.js"></script>
</head>
<body>
<div id="not-supported" style="float: left; width: 600px; margin-left: 10px; display: none">
    <p>Uh-oh, the browser you're using doesn't have native support for WebSocket. That means you can't run this
        demo.</p>
    <p>The following link lists the browsers that support WebSocket:</p>
    <p><a href="http://caniuse.com/#feat=websockets">http://caniuse.com/#feat=websockets</a></p>
</div>
<table>
    <tr>
        <td>
            <div>Enter a message below to send</div>
            <input type="text" id="msg"/>
            <input type="submit" value="Send" id="send"/>
        </td>
        <td id="ui">
            <input type="text" id="url"/>
            <textarea id="log" disabled></textarea>
            <input type="submit" id="connect" value="Connect"/>
        </td>
    </tr>
</table>
<canvas id="canvas" tabindex="1"></canvas>
</body>
<script type="text/javascript">

    // RequestAnimFrame: a browser API for getting smooth animations
    window.requestAnimFrame = (function () {
        return window.requestAnimationFrame ||
                window.webkitRequestAnimationFrame ||
                window.mozRequestAnimationFrame ||
                window.oRequestAnimationFrame ||
                window.msRequestAnimationFrame ||
                function (callback) {
                    return window.setTimeout(callback, 1000 / 60);
                };
    })();
    window.cancelRequestAnimFrame = (function () {
        return window.cancelAnimationFrame ||
                window.webkitCancelRequestAnimationFrame ||
                window.mozCancelRequestAnimationFrame ||
                window.oCancelRequestAnimationFrame ||
                window.msCancelRequestAnimationFrame ||
                clearTimeout
    })();
    // Initialize canvasElm and required variables
    var canvasElm = document.getElementById("canvas"),
            canvas = canvasElm.getContext("2d");
    canvasElm.width = window.innerWidth;
    canvasElm.height = window.innerHeight / 2;


    var game = new Game(canvas);

    function Point(x, y) {
        this.x = x;
        this.y = y;

        this.next = function (direction) {
            var nextp = new Point(this.x, this.y);
            switch (direction) {
                case 'r':
                    nextp.x += 1;
                    break;
                case 'l':
                    nextp.x -= 1;
                    break;
                case 'u':
                    nextp.y -= 1;
                    break;
                case 'd':
                    nextp.y += 1;
                    break;
            }
            return nextp;
        }

        this.equals = function (b) {
            try {
                if (this.x === b.x && this.y === b.y) {
                    return true;
                }
                return false;
            }
            catch (e) {
                return false;
            }
        }
    }

    function Snake() {
        this.dots = [];
        for (var i = 0; i < 50; i++) {
            this.dots.push(new Point(0, i));
        }
        this.direction = 'd';

        this.turn = function (dir) {
            if (['r', 'l', 'u', 'd'].indexOf(dir) == -1)
                return;
            if (this.validMove(dir))
                this.direction = dir;
            else
                return;
        }

        this.validMove = function (dir) {
            var last2p = this.dots[this.dots.length - 2];
            var lastp = this.dots[this.dots.length - 1];
            if (lastp.next(dir).equals(last2p))
                return false;
            return true;
        }

        this.move = function (canvas) {
            var lastp = this.dots[this.dots.length - 1];
            var nextp = lastp.next(this.direction);
            var fruitInx = _.findIndex(game.fruits, {x: lastp.x, y: lastp.y});
            this.dots.push(nextp);
            if (fruitInx != -1)
                game.fruits.splice(fruitInx, 1);
            else
                this.dots = this.dots.slice(1);
        }

        this.draw = function (canvas) {
//            canvasElm.lineWidth = 1;
            canvas.strokeStyle = "red";
            canvas.beginPath();
            canvas.moveTo(this.dots[0].x, this.dots[0].y);
            for (var i = 0; i < this.dots.length; ++i)
                canvas.lineTo(this.dots[i].x, this.dots[i].y);
            canvas.stroke();
        }
    }

    function Game(canvas) {
        this.snake = new Snake();
        this.canvas = canvas;
        this.fruits = [];

        this.draw = function () {
            this.canvas.fillRect(0, 0, window.innerWidth, window.innerHeight / 2);
            this.snake.draw(canvas);
            this.snake.move(canvas);
            this.fillFruits()
        }

        this.fillFruits = function () {
            for (var i = 0; i < this.fruits.length; i++) {
                this.canvas.beginPath();
                this.canvas.fillStyle = "yellow";
                this.canvas.fillRect(this.fruits[i].x, this.fruits[i].y, 1, 1);
                this.canvas.fillStyle = "black";
            }
        }

        this.drawFruits = function () {
            for (var i = 0; i < 50; i++) {
                var x = Math.floor((Math.random() * window.innerWidth) + 1);
                var y = Math.floor((Math.random() * window.innerHeight / 2) + 1);
                this.fruits.push(new Point(x, y));
            }
        }

        this.drawFruits();
    }
    game.animLoop = function () {
        requestAnimFrame(game.animLoop);
        game.draw();
    }

    game.draw();

    document.addEventListener('keydown', function (event) {
        var keymap = {'37': 'l', '38': 'u', '39': 'r', '40': 'd'};
        game.snake.turn(keymap[event.keyCode.toString()]);
    }, false);
    canvasElm.addEventListener("mousedown", game.animLoop, true);

    function log(msg) {
        var log = $('#log');
        log.append(msg + " \n").scrollTop(log[0].scrollHeight - log.height());
    }

    $(function () {
        $('#url').val((location.protocol.indexOf('https') == -1 ? 'ws://' : 'wss://') + location.host + '/ws');

        if (!WebSocket) {
            $('#not-supported').show();
        } else {
            var ws = null;
            $('#connect').click(function () {
                if (ws == null || ws.readyState != 1) {
                    ws = new WebSocket($('#url').val());
                    ws.onerror = function (e) {
                        log('Error : ' + e.message);
                    }
                    ws.onopen = function () {
                        log('connected');
                    }
                    ws.onclose = function () {
                        log('disconnected');
                    }
                    ws.onmessage = function (d) {
                        log('Response : ' + d.data);
                    }
                    $('#send').click(function () {
                        var msg = $('#msg').val();
                        $('#msg').val('');
                        try {
                            ws.send(msg);
                            log('Message sent');
                        }
                        catch (ex) {
                            log('Message not sent due to' + ex);
                        }
                    })
                } else {
                    log('closing connection');
                    ws.close();
                }
            });
        }
    });
</script>
</html>